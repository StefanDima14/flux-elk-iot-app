# helmrelease-elasticsearch.yaml
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: elk-cluster
  namespace: elk-cluster
spec:
  interval: 1m
  releaseName: elk-iot-cluster
  targetNamespace: elk-cluster
  chart:
    spec:
      chart: ./charts/elasticsearch
      sourceRef:
        kind: GitRepository
        name: eck-elasticsearch-stack
        namespace: flux-system
  values:
    # Identity
    fullnameOverride: "elk-iot-cluster"
    version: 8.8.0

    # Topology: 3 master+data nodes
    nodeSets:
      - name: default
        count: 3
        config:
          node.store.allow_mmap: false
          node.roles:
            - master
            - data
        podTemplate:
          spec:
            containers:
              - name: elasticsearch
                resources:
                  requests:
                    cpu: 500m
                    memory: 1Gi
                  limits:
                    cpu: 1
                    memory: 1Gi

    # Rolling upgrades
    updateStrategy:
      changeBudget:
        maxSurge: 1
        maxUnavailable: 0

    # PodDisruptionBudget
    podDisruptionBudget:
      disabled: false
      spec:
        minAvailable: 2
        selector:
          matchLabels:
            elasticsearch.k8s.elastic.co/cluster-name: elk-iot-cluster

    # Clean up PVCs on delete
    volumeClaimDeletePolicy: DeleteOnScaledownAndClusterDeletion

    # Do not expose ES HTTP directly
    ingress:
      enabled: false

---
# helmrelease-kibana.yaml
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: kibana
  namespace: elk-cluster
spec:
  interval: 5m
  releaseName: kibana-iot
  targetNamespace: elk-cluster
  chart:
    spec:
      chart: ./charts/kibana
      sourceRef:
        kind: GitRepository
        name: eck-elasticsearch-stack
        namespace: flux-system
      version: 8.8.0
  values:
    # Basic settings
    fullnameOverride: "kibana-iot"
    version: 8.8.0
    count: 1

    # Point to the ES service in-cluster
    elasticsearchRef:
      name: elk-iot-cluster
    # http:
    #   service:
    #     metadata:
    #       annotations:
    #         cloud.google.com/neg: '{"ingress": true}'
    #     spec:
    #       type: ClusterIP
    http:
      service:
        spec:
          type: LoadBalancer
          loadBalancerIP: 34.116.188.128 # Static IP for GKE LoadBalancer created gcloud compute addresses create kibana-svc-ip --region=europe-central2    # or your GKE region

          ports:
            - name: http
              port: 80
              targetPort: 5601
          externalTrafficPolicy: Local
    # Expose only Kibana
    # ingress:
    #   enabled: true
    #   className: gce
    #   annotations:
    #     kubernetes.io/ingress.class: gce
    #   pathType: Prefix
    #   hosts:
    #     - host: kibana.34-96-118-192.nip.io
    #       path: /
          
    #   tls:
    #     enabled: false

    # Public URL for reverse proxy
    config:
      server:
        publicBaseUrl: "http://kibana.34.116.188.128.nip.io"
